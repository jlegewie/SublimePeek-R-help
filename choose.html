<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
 <html><head><title>R: Special Functions of Mathematics</title>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <link rel="stylesheet" type="text/css" href="R.css">
 </head><body>
 
 <table width="100%" summary="page for Special"><tr><td>Special</td><td align="right">R Documentation</td></tr></table>
 
 <h2>Special Functions of Mathematics</h2>
 
 <h3>Description</h3>
 
 
 <p>Special mathematical functions related to the beta and gamma
 functions.
 </p>
 
 
 <h3>Usage</h3>
 
 <pre>
 beta(a, b)
 lbeta(a, b)
 
 gamma(x)
 lgamma(x)
 psigamma(x, deriv = 0)
 digamma(x)
 trigamma(x)
 
 choose(n, k)
 lchoose(n, k)
 factorial(x)
 lfactorial(x)
 </pre>
 
 
 <h3>Arguments</h3>
 
 
 <table summary="R argblock">
 <tr valign="top"><td><code>a, b</code></td>
 <td>
 <p>non-negative numeric vectors.</p>
 </td></tr>
 <tr valign="top"><td><code>x, n</code></td>
 <td>
 <p>numeric vectors.</p>
 </td></tr>
 <tr valign="top"><td><code>k, deriv</code></td>
 <td>
 <p>integer vectors.</p>
 </td></tr>
 </table>
 
 
 <h3>Details</h3>
 
 
 <p>The functions <code>beta</code> and <code>lbeta</code> return the beta function
 and the natural logarithm of the beta function,
 </p>
 <p align="center"><i>B(a,b) = &Gamma;(a)&Gamma;(b)/&Gamma;(a+b).</i></p>
 
 <p>The formal definition is
 </p>
 <p align="center"><i>integral_0^1 t^(a-1) (1-t)^(b-1) dt</i></p>
 
 <p>(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is only
 defined in <font face="Courier New,Courier" color="#666666"><b>R</b></font> for non-negative <code>a</code> and <code>b</code>, and is infinite
 if either is zero.
 </p>
 <p>The functions <code>gamma</code> and <code>lgamma</code> return the gamma function
 <i>&Gamma;(x)</i> and the natural logarithm of <EM>the absolute value of</EM> the
 gamma function.  The gamma function is defined by
 (Abramowitz and Stegun section 6.1.1, page 255)
 </p>
 <p align="center"><i>&Gamma;(x) = integral_0^Inf t^(x-1) exp(-t) dt</i></p>
 
 <p>for all real <code>x</code> except zero and negative integers (when
 <code>NaN</code> is returned).  There will be a warning on possible loss of
 precision for values which are too close (within about
 <i>1e-8</i>)) to a negative integer less than <span class="samp">-10</span>.
 </p>
 <p><code>factorial(x)</code> (<i>x!</i> for non-negative integer <code>x</code>)
 is defined to be <code>gamma(x+1)</code> and <code>lfactorial</code> to be
 <code>lgamma(x+1)</code>.
 </p>
 <p>The functions <code>digamma</code> and <code>trigamma</code> return the first and second
 derivatives of the logarithm of the gamma function.
 <code>psigamma(x, deriv)</code> (<code>deriv &gt;= 0</code>) computes the
 <code>deriv</code>-th derivative of <i>&psi;(x)</i>.
 </p>
 <p align="center"><i>digamma(x) = &psi;(x) = d/dx{ln &Gamma;(x)} = &Gamma;'(x) / &Gamma;(x)</i></p>
 
 <p>This is often called the &lsquo;polygamma&rsquo; function, e.g. in
 Abramowitz and Stegun (section 6.4.1, page 260); and higher
 derivatives (<code>deriv = 2:4</code>) have occasionally been called
 &lsquo;tetragamma&rsquo;, &lsquo;pentagamma&rsquo;, and &lsquo;hexagamma&rsquo;.
 </p>
 <p>The functions <code>choose</code> and <code>lchoose</code> return binomial
 coefficients and the logarithms of their absolute values.  Note that
 <code>choose(n,k)</code> is defined for all real numbers <i>n</i> and integer
 <i>k</i>.  For <i>k &ge; 1</i> it is defined as
 <i>n(n-1)&hellip;(n-k+1) / k!</i>,
 as <i>1</i> for <i>k = 0</i> and as <i>0</i> for negative <i>k</i>.
 Non-integer values of <code>k</code> are rounded to an integer, with a warning.
 <br> <code>choose(*,k)</code> uses direct arithmetic (instead of
 <code>[l]gamma</code> calls) for small <code>k</code>, for speed and accuracy
 reasons.  Note the function <code>combn</code> (package
 <span class="pkg">utils</span>) for enumeration of all possible combinations.
 </p>
 <p>The <code>gamma</code>, <code>lgamma</code>, <code>digamma</code> and <code>trigamma</code>
 functions are internal generic primitive functions: methods can be
 defined for them individually or via the
 <code>Math</code> group generic.
 </p>
 
 
 <h3>Source</h3>
 
 
 <p><code>gamma</code>, <code>lgamma</code>, <code>beta</code> and <code>lbeta</code> are based on
 C translations of Fortran subroutines by W. Fullerton of Los Alamos
 Scientific Laboratory (now available as part of SLATEC).
 </p>
 <p><code>digamma</code>, <code>trigamma</code> and <code>psigamma</code> are based on
 </p>
 <p>Amos, D. E. (1983). A portable Fortran subroutine for
 derivatives of the psi function, Algorithm 610,
 <EM>ACM Transactions on Mathematical Software</EM> <B>9(4)</B>, 494&ndash;502.
 </p>
 
 
 <h3>References</h3>
 
 
 <p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
 <EM>The New S Language</EM>.
 Wadsworth &amp; Brooks/Cole. (For <code>gamma</code> and <code>lgamma</code>.)
 </p>
 <p>Abramowitz, M. and Stegun, I. A. (1972)
 <EM>Handbook of Mathematical Functions.</EM> New York: Dover.
 Chapter 6: Gamma and Related Functions.
 </p>
 
 
 <h3>See Also</h3>
 
 
 <p><code>Arithmetic</code> for simple, <code>sqrt</code> for
 miscellaneous mathematical functions and <code>Bessel</code> for the
 real Bessel functions.
 </p>
 <p>For the incomplete gamma function see <code>pgamma</code>.
 </p>
 
 
 <h3>Examples</h3>
 
 <pre>
 require(graphics)
 
 choose(5, 2)
 for (n in 0:10) print(choose(n, k = 0:n))
 
 factorial(100)
 lfactorial(10000)
 
 ## gamma has 1st order poles at 0, -1, -2, ...
 ## this will generate loss of precision warnings, so turn off
 op &lt;- options("warn")
 options(warn = -1)
 x &lt;- sort(c(seq(-3,4, length.out=201), outer(0:-3, (-1:1)*1e-6, "+")))
 plot(x, gamma(x), ylim=c(-20,20), col="red", type="l", lwd=2,
      main=expression(Gamma(x)))
 abline(h=0, v=-3:0, lty=3, col="midnightblue")
 options(op)
 
 x &lt;- seq(.1, 4, length.out = 201); dx &lt;- diff(x)[1]
 par(mfrow = c(2, 3))
 for (ch in c("", "l","di","tri","tetra","penta")) {
   is.deriv &lt;- nchar(ch) &gt;= 2
   nm &lt;- paste(ch, "gamma", sep = "")
   if (is.deriv) {
     dy &lt;- diff(y) / dx # finite difference
     der &lt;- which(ch == c("di","tri","tetra","penta")) - 1
     nm2 &lt;- paste("psigamma(*, deriv = ", der,")",sep='')
     nm  &lt;- if(der &gt;= 2) nm2 else paste(nm, nm2, sep = " ==\n")
     y &lt;- psigamma(x, deriv=der)
   } else {
     y &lt;- get(nm)(x)
   }
   plot(x, y, type = "l", main = nm, col = "red")
   abline(h = 0, col = "lightgray")
   if (is.deriv) lines(x[-1], dy, col = "blue", lty = 2)
 }
 par(mfrow = c(1, 1))
 
 ## "Extended" Pascal triangle:
 fN &lt;- function(n) formatC(n, width=2)
 for (n in -4:10) cat(fN(n),":", fN(choose(n, k= -2:max(3,n+2))), "\n")
 
 ## R code version of choose()  [simplistic; warning for k &lt; 0]:
 mychoose &lt;- function(r,k)
     ifelse(k &lt;= 0, (k==0),
            sapply(k, function(k) prod(r:(r-k+1))) / factorial(k))
 k &lt;- -1:6
 cbind(k=k, choose(1/2, k), mychoose(1/2, k))
 
 ## Binomial theorem for n=1/2 ;
 ## sqrt(1+x) = (1+x)^(1/2) = sum_{k=0}^Inf  choose(1/2, k) * x^k :
 k &lt;- 0:10 # 10 is sufficient for ~ 9 digit precision:
 sqrt(1.25)
 sum(choose(1/2, k)* .25^k)
 
 
 </pre>
 
 
 </body></html>
