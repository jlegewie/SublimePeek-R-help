<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
 <html><head><title>R: Interpolating Splines</title>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <link rel="stylesheet" type="text/css" href="R.css">
 </head><body>
 
 <table width="100%" summary="page for splinefun"><tr><td>splinefun</td><td align="right">R Documentation</td></tr></table>
 
 <h2>Interpolating Splines</h2>
 
 <h3>Description</h3>
 
 
 <p>Perform cubic (or Hermite) spline interpolation of given data points,
 returning either a list of points obtained by the interpolation or a
 <EM>function</EM> performing the interpolation.
 </p>
 
 
 <h3>Usage</h3>
 
 <pre>
 splinefun(x, y = NULL,
           method = c("fmm", "periodic", "natural", "monoH.FC"),
           ties = mean)
 
 spline(x, y = NULL, n = 3*length(x), method = "fmm",
        xmin = min(x), xmax = max(x), xout, ties = mean)
 
 splinefunH(x, y, m)
 </pre>
 
 
 <h3>Arguments</h3>
 
 
 <table summary="R argblock">
 <tr valign="top"><td><code>x,y</code></td>
 <td>
 <p>vectors giving the coordinates of the points to be
 interpolated.  Alternatively a single plotting structure can be
 specified: see <code>xy.coords.</code></p>
 </td></tr>
 <tr valign="top"><td><code>m</code></td>
 <td>
 <p>(for <code>splinefunH()</code>): vector of <EM>slopes</EM>
 <i>m[i]</i> at the points <i>(x[i],y[i])</i>; these
 together determine the <B>H</B>ermite &ldquo;spline&rdquo; which is
 piecewise cubic, (only) <EM>once</EM> differentiable continuously.</p>
 </td></tr>
 <tr valign="top"><td><code>method</code></td>
 <td>
 <p>specifies the type of spline to be used.  Possible
 values are <code>"fmm"</code>, <code>"natural"</code>, <code>"periodic"</code> and
 <code>"monoH.FC"</code>.</p>
 </td></tr>
 <tr valign="top"><td><code>n</code></td>
 <td>
 <p>if <code>xout</code> is left unspecified, interpolation takes place
 at <code>n</code> equally spaced points spanning the interval
 [<code>xmin</code>, <code>xmax</code>].</p>
 </td></tr>
 <tr valign="top"><td><code>xmin, xmax</code></td>
 <td>
 <p>left-hand and right-hand endpoint of the
 interpolation interval (when <code>xout</code> is unspecified).</p>
 </td></tr>
 <tr valign="top"><td><code>xout</code></td>
 <td>
 <p>an optional set of values specifying where interpolation
 is to take place.</p>
 </td></tr>
 <tr valign="top"><td><code>ties</code></td>
 <td>
 <p>Handling of tied <code>x</code> values.  Either a function
 with a single vector argument returning a single number result or
 the string <code>"ordered"</code>.</p>
 </td></tr>
 </table>
 
 
 <h3>Details</h3>
 
 
 <p>The inputs can contain missing values which are deleted, so at least
 one complete <code>(x, y)</code> pair is required.
 If <code>method = "fmm"</code>, the spline used is that of Forsythe, Malcolm
 and Moler (an exact cubic is fitted through the four points at each
 end of the data, and this is used to determine the end conditions).
 Natural splines are used when <code>method = "natural"</code>, and periodic
 splines when <code>method = "periodic"</code>.
 </p>
 <p>The new (R 2.8.0) method <code>"monoH.FC"</code> computes a <EM>monotone</EM>
 Hermite spline according to the method of Fritsch and Carlson.  It
 does so by determining slopes such that the Hermite spline, determined
 by <i>(x[i],y[i],m[i])</i>, is monotone (increasing or
 decreasing) <B>iff</B> the data are.
 </p>
 <p>These interpolation splines can also be used for extrapolation, that is
 prediction at points outside the range of <code>x</code>.  Extrapolation
 makes little sense for <code>method = "fmm"</code>; for natural splines it
 is linear using the slope of the interpolating curve at the nearest
 data point.
 </p>
 
 
 <h3>Value</h3>
 
 
 <p><code>spline</code> returns a list containing components <code>x</code> and
 <code>y</code> which give the ordinates where interpolation took place and
 the interpolated values.
 </p>
 <p><code>splinefun</code> returns a function with formal arguments <code>x</code> and
 <code>deriv</code>, the latter defaulting to zero.  This function
 can be used to evaluate the interpolating cubic spline
 (<code>deriv</code>=0), or its derivatives (<code>deriv</code>=1,2,3) at the
 points <code>x</code>, where the spline function interpolates the data
 points originally specified.  This is often more useful than
 <code>spline</code>.
 </p>
 
 
 <h3>References</h3>
 
 
 <p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
 <EM>The New S Language</EM>.
 Wadsworth &amp; Brooks/Cole.
 </p>
 <p>Forsythe, G. E., Malcolm, M. A. and Moler, C. B. (1977)
 <EM>Computer Methods for Mathematical Computations</EM>.
 </p>
 <p>Fritsch, F. N. and Carlson, R. E. (1980)
 Monotone piecewise cubic interpolation, <EM>SIAM Journal on
 Numerical Analysis</EM> <B>17</B>, 238&ndash;246.
 </p>
 
 
 <h3>See Also</h3>
 
 
 <p><code>approx</code> and <code>approxfun</code> for constant and
 linear interpolation.
 </p>
 <p>Package <span class="pkg">splines</span>, especially <code>interpSpline</code>
 and <code>periodicSpline</code> for interpolation splines.
 That package also generates spline bases that can be used for
 regression splines.
 </p>
 <p><code>smooth.spline</code> for smoothing splines.
 </p>
 
 
 <h3>Examples</h3>
 
 <pre>
 require(graphics)
 
 op &lt;- par(mfrow = c(2,1), mgp = c(2,.8,0), mar = .1+c(3,3,3,1))
 n &lt;- 9
 x &lt;- 1:n
 y &lt;- rnorm(n)
 plot(x, y, main = paste("spline[fun](.) through", n, "points"))
 lines(spline(x, y))
 lines(spline(x, y, n = 201), col = 2)
 
 y &lt;- (x-6)^2
 plot(x, y, main = "spline(.) -- 3 methods")
 lines(spline(x, y, n = 201), col = 2)
 lines(spline(x, y, n = 201, method = "natural"), col = 3)
 lines(spline(x, y, n = 201, method = "periodic"), col = 4)
 legend(6,25, c("fmm","natural","periodic"), col=2:4, lty=1)
 
 y &lt;- sin((x-0.5)*pi)
 f &lt;- splinefun(x, y)
 ls(envir = environment(f))
 splinecoef &lt;- get("z", envir = environment(f))
 curve(f(x), 1, 10, col = "green", lwd = 1.5)
 points(splinecoef, col = "purple", cex = 2)
 curve(f(x, deriv=1), 1, 10, col = 2, lwd = 1.5)
 curve(f(x, deriv=2), 1, 10, col = 2, lwd = 1.5, n = 401)
 curve(f(x, deriv=3), 1, 10, col = 2, lwd = 1.5, n = 401)
 par(op)
 
 ## Manual spline evaluation --- demo the coefficients :
 .x &lt;- splinecoef$x
 u &lt;- seq(3,6, by = 0.25)
 (ii &lt;- findInterval(u, .x))
 dx &lt;- u - .x[ii]
 f.u &lt;- with(splinecoef,
             y[ii] + dx*(b[ii] + dx*(c[ii] + dx* d[ii])))
 stopifnot(all.equal(f(u), f.u))
 
 ## An example with ties (non-unique  x values):
 set.seed(1); x &lt;- round(rnorm(30), 1); y &lt;- sin(pi * x) + rnorm(30)/10
 plot(x,y, main="spline(x,y)  when x has ties")
 lines(spline(x,y, n= 201), col = 2)
 ## visualizes the non-unique ones:
 tx &lt;- table(x); mx &lt;- as.numeric(names(tx[tx &gt; 1]))
 ry &lt;- matrix(unlist(tapply(y, match(x,mx), range, simplify=FALSE)),
              ncol=2, byrow=TRUE)
 segments(mx, ry[,1], mx, ry[,2], col = "blue", lwd = 2)
 
 ## An example of  monotone  interpolation
 n &lt;- 20
 set.seed(11)
 x. &lt;- sort(runif(n)) ; y. &lt;- cumsum(abs(rnorm(n)))
 plot(x.,y.)
 curve(splinefun(x.,y.)(x),                add=TRUE, col=2, n=1001)
 curve(splinefun(x.,y., method="mono")(x), add=TRUE, col=3, n=1001)
 legend("topleft",
        paste("splinefun( \"", c("fmm", "monoH.CS"), "\" )", sep=''),
        col = 2:3, lty = 1)
 </pre>
 
 
 </body></html>
