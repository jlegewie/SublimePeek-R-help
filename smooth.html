<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
 <html><head><title>R: Tukey's (Running Median) Smoothing</title>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <link rel="stylesheet" type="text/css" href="R.css">
 </head><body>
 
 <table width="100%" summary="page for smooth"><tr><td>smooth</td><td align="right">R Documentation</td></tr></table>
 
 <h2>Tukey's (Running Median) Smoothing</h2>
 
 <h3>Description</h3>
 
 
 <p>Tukey's smoothers, <EM>3RS3R</EM>, <EM>3RSS</EM>, <EM>3R</EM>, etc.
 </p>
 
 
 <h3>Usage</h3>
 
 <pre>
 smooth(x, kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"),
        twiceit = FALSE, endrule = "Tukey", do.ends = FALSE)
 </pre>
 
 
 <h3>Arguments</h3>
 
 
 <table summary="R argblock">
 <tr valign="top"><td><code>x</code></td>
 <td>
 <p>a vector or time series</p>
 </td></tr>
 <tr valign="top"><td><code>kind</code></td>
 <td>
 <p>a character string indicating the kind of smoother required;
 defaults to <code>"3RS3R"</code>.</p>
 </td></tr>
 <tr valign="top"><td><code>twiceit</code></td>
 <td>
 <p>logical, indicating if the result should be &lsquo;twiced&rsquo;.
 Twicing a smoother <i>S(y)</i> means <i>S(y) + S(y - S(y))</i>, i.e.,
 adding smoothed residuals to the smoothed values.  This decreases
 bias (increasing variance).</p>
 </td></tr>
 <tr valign="top"><td><code>endrule</code></td>
 <td>
 <p>a character string indicating the rule for smoothing at the
 boundary.  Either <code>"Tukey"</code> (default) or <code>"copy"</code>.</p>
 </td></tr>
 <tr valign="top"><td><code>do.ends</code></td>
 <td>
 <p>logical, indicating if the 3-splitting of ties should
 also happen at the boundaries (ends).  This is only used for
 <code>kind = "S"</code>.</p>
 </td></tr>
 </table>
 
 
 <h3>Details</h3>
 
 
 <p><EM><code>3</code></EM> is Tukey's short notation for running <code>median</code>s
 of length <B>3</B>,
 <br>
 <EM><code>3R</code></EM> stands for <B>R</B>epeated <EM><code>3</code></EM> until
 convergence, and
 <br>
 <EM><code>S</code></EM> for <B>S</B>plitting of horizontal stretches of length 2 or 3.
 </p>
 <p>Hence, <EM><code>3RS3R</code></EM> is a concatenation of <code>3R</code>, <code>S</code>
 and <code>3R</code>, <EM><code>3RSS</code></EM> similarly,
 whereas <EM><code>3RSR</code></EM> means first <code>3R</code>
 and then <code>(S and 3)</code> <B>R</B>epeated until convergence &ndash; which
 can be bad.
 </p>
 
 
 <h3>Value</h3>
 
 
 <p>An object of class <code>"tukeysmooth"</code> (which has <code>print</code> and
 <code>summary</code> methods) and is a vector or time series containing the
 smoothed values with additional attributes.
 </p>
 
 
 <h3>Note</h3>
 
 
 <p>S and S-PLUS use a different (somewhat better) Tukey smoother in
 <code>smooth(*)</code>.
 Note that there are other smoothing methods which provide
 rather better results.  These were designed for hand calculations
 and may be used mainly for didactical purposes.
 </p>
 <p>Since <font face="Courier New,Courier" color="#666666"><b>R</b></font> version 1.2, <code>smooth</code> <EM>does</EM> really implement
 Tukey's end-point rule correctly (see argument <code>endrule</code>).
 </p>
 <p><code>kind = "3RSR"</code> has been the default till <font face="Courier New,Courier" color="#666666"><b>R</b></font>-1.1,
 but it can have very bad properties, see the examples.
 </p>
 <p>Note that repeated application of <code>smooth(*)</code> <EM>does</EM>
 smooth more, for the <code>"3RS*"</code> kinds.
 </p>
 
 
 <h3>References</h3>
 
 
 <p>Tukey, J. W. (1977).
 <EM>Exploratory Data Analysis</EM>,
 Reading Massachusetts: Addison-Wesley.
 </p>
 
 
 <h3>See Also</h3>
 
 
 <p><code>lowess</code>;
 <code>loess</code>,
 <code>supsmu</code> and
 <code>smooth.spline</code>.
 </p>
 
 
 <h3>Examples</h3>
 
 <pre>
 require(graphics)
 
 ## see also   demo(smooth) !
 
 x1 &lt;- c(4, 1, 3, 6, 6, 4, 1, 6, 2, 4, 2) # very artificial
 (x3R &lt;- smooth(x1, "3R")) # 2 iterations of "3"
 smooth(x3R, kind = "S")
 
 sm.3RS &lt;- function(x, ...)
    smooth(smooth(x, "3R", ...), "S", ...)
 
 y &lt;- c(1,1, 19:1)
 plot(y, main = "misbehaviour of \"3RSR\"", col.main = 3)
 lines(sm.3RS(y))
 lines(smooth(y))
 lines(smooth(y, "3RSR"), col = 3, lwd = 2)# the horror
 
 x &lt;- c(8:10,10, 0,0, 9,9)
 plot(x, main = "breakdown of  3R  and  S  and hence  3RSS")
 matlines(cbind(smooth(x,"3R"),smooth(x,"S"), smooth(x,"3RSS"),smooth(x)))
 
 presidents[is.na(presidents)] &lt;- 0 # silly
 summary(sm3 &lt;- smooth(presidents, "3R"))
 summary(sm2 &lt;- smooth(presidents,"3RSS"))
 summary(sm  &lt;- smooth(presidents))
 
 all.equal(c(sm2),c(smooth(smooth(sm3, "S"), "S"))) # 3RSS  === 3R S S
 all.equal(c(sm), c(smooth(smooth(sm3, "S"), "3R")))# 3RS3R === 3R S 3R
 
 plot(presidents, main = "smooth(presidents0, *) :  3R and default 3RS3R")
 lines(sm3,col = 3, lwd = 1.5)
 lines(sm, col = 2, lwd = 1.25)
 </pre>
 
 
 </body></html>
